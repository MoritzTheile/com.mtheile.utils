package com.lithodat.app.litho.service.MODULNAME_LOWERCASE_TOKEN;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.lithodat.app.domain.ENTITYNAME_TOKEN;
import com.lithodat.app.domain.ENTITYNAME_TOKEN_;
import com.lithodat.app.litho.service.dto.ParamDTO;
import com.lithodat.app.litho.service.util.AuthzException;
import com.lithodat.app.litho.service.util.Bouncer.BounceDecision;
import com.lithodat.app.repository.ENTITYNAME_TOKENRepository;
import com.lithodat.app.litho.service.util.FrequentlyUsedBeans;
import com.lithodat.app.litho.service.util.LithoAuth;
import com.lithodat.app.litho.service.util.LithoCRUD;
import com.lithodat.app.service.ENTITYNAME_TOKENQueryService;
import com.lithodat.app.service.ENTITYNAME_TOKENService;
import com.lithodat.app.service.dto.ENTITYNAME_TOKENDTO;
import com.lithodat.app.service.dto.ENTITYNAME_TOKENCriteria;
import com.lithodat.app.service.dto.ENTITYNAME_TOKENDTO;
import com.lithodat.app.service.mapper.ENTITYNAME_TOKENMapper;

@Service
public class ENTITYNAME_TOKENLithoService implements LithoCRUD<ENTITYNAME_TOKENDTO, ENTITYNAME_TOKENCriteria> {

	@Autowired
	private FrequentlyUsedBeans fub;

	@Autowired
	private ENTITYNAME_TOKENService service;

	@Autowired
	private ENTITYNAME_TOKENQueryService queryService;

	@Autowired 
	private ENTITYNAME_TOKENRepository repository;
	
	@Autowired 
	private ENTITYNAME_TOKENMapper mapper;

	@Transactional
	public ENTITYNAME_TOKENDTO create(LithoAuth lithoAuth, ENTITYNAME_TOKENDTO dto, ParamDTO params) throws Exception {

		{ // bouncing

			BounceDecision bounceDecision = fub.bouncer.getDecisionFor(lithoAuth);

			bounceDecision.allowEntryIf(bounceDecision.userIsAdmin());

		}

		return service.save(dto);
	}

	public Optional<ENTITYNAME_TOKENDTO> findOne(LithoAuth lithoAuth, Long id) throws AuthzException {

		{ // bouncing

			BounceDecision bounceDecision = fub.bouncer.getDecisionFor(lithoAuth);

			bounceDecision.allowEntryIf(bounceDecision.userIsGiven());

		}

		return service.findOne(id);

	}

	public Long countByCriteria(LithoAuth lithoAuth, ENTITYNAME_TOKENCriteria criteria) throws AuthzException {

		{ // bouncing

			BounceDecision bounceDecision = fub.bouncer.getDecisionFor(lithoAuth);

			bounceDecision.allowEntryIf(bounceDecision.userIsGiven());

		}

		return queryService.countByCriteria(criteria);

	}

	public Page<ENTITYNAME_TOKENDTO> findByCriteria(final LithoAuth lithoAuth, ENTITYNAME_TOKENCriteria criteria, Pageable pageable) throws AuthzException {

		{ // bouncing

			BounceDecision bounceDecision = fub.bouncer.getDecisionFor(lithoAuth);

			bounceDecision.allowEntryIf(bounceDecision.userIsGiven());

		}

		return queryService.findByCriteria(criteria, pageable);

	}

	@Override
	public ENTITYNAME_TOKENDTO update(LithoAuth lithoAuth, ENTITYNAME_TOKENDTO dto) throws Exception {

		{ // bouncing

			BounceDecision bounceDecision = fub.bouncer.getDecisionFor(lithoAuth);

			bounceDecision.allowEntryIf(bounceDecision.userIsAdmin());

		}

		return service.save(dto);

	}

	public void delete(LithoAuth lithoAuth, Long id) throws AuthzException {

		{ // bouncing

			BounceDecision bounceDecision = fub.bouncer.getDecisionFor(lithoAuth);

			bounceDecision.allowEntryIf(bounceDecision.userIsAdmin());

		}

		service.delete(id);
	}

	public ENTITYNAME_TOKENDTO findSingleResult(LithoAuth lithoAuth, String searchTerm) throws Exception {
		return mapper.toDto(findSingleResult(searchTerm, false));
	}

	public ENTITYNAME_TOKEN findSingleResult(String searchTerm, boolean perfectMatch) throws Exception {

		List<ENTITYNAME_TOKEN> findAll = repository.findAll(matchName(searchTerm, perfectMatch));

		if (findAll.isEmpty()) {
			throw new Exception("No ENTITYNAME_TOKEN could be found for \"" + searchTerm + "\"");
		}

		if (findAll.size() > 1) {
			throw new Exception("More than one ENTITYNAME_TOKEN was found for \"" + searchTerm + "\": " + findAll.stream().map(elevationKind -> elevationKind.getName()).collect(Collectors.toList()));
		}

		return findAll.iterator().next();

	}

	private static Specification<ENTITYNAME_TOKEN> matchName(String seachTerm, boolean perfectMatch) {
		
		if(perfectMatch) {
			
			return (root, query, criteriaBuilder) -> criteriaBuilder.equal(root.get(ENTITYNAME_TOKEN_.name),  seachTerm );
			
		}else {
			
			return (root, query, criteriaBuilder) -> criteriaBuilder.like(root.get(ENTITYNAME_TOKEN_.name), "%" + seachTerm + "%");
			
		}
	}

}
